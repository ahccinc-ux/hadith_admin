import { Component, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, RouterLink } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { HadithService } from '../../core/services/hadith';

// Helper function to get ID from hadith item
function getHadithId(item: any): number {
  return Number(item?._hadithNewOrg?.h_id ?? item?.h_id ?? 0);
}

@Component({
  selector: 'app-hadith',
  standalone: true,
  imports: [CommonModule, RouterLink, FormsModule],
  template: `
    <div class="container" dir="rtl">
      <!-- Toast Notification -->
      <div class="toast" *ngIf="toastMessage()" [class.error]="toastType() === 'error'" [class.success]="toastType() === 'success'">
        {{ toastMessage() }}
      </div>
      
      <header class="header">
        <a class="back" [routerLink]="['/babs', catId(), chapterId()]" [queryParams]="{ name: chapterName(), parent: writerName(), book: bookName() }" aria-label="رجوع">
          ← رجوع
        </a>
        <h1>الأحاديث</h1>
        <div class="meta">
          <div><strong>الكتاب:</strong> {{ writerName() }}</div>
          <div><strong>الفصل:</strong> {{ chapterName() }}</div>
          <div><strong>الباب:</strong> {{ babName() }}</div>
        </div>
      </header>

      <ng-container *ngIf="!error(); else errorTpl">
        <section *ngIf="loaded(); else loadingTpl">
          <div *ngIf="items().length; else emptyTpl" class="list">
            <article class="hadith" *ngFor="let item of items(); trackBy: trackById" tabindex="0">
              <div class="actions">
                <button class="btn secondary" *ngIf="!isEditing(getId(item))" (click)="startEdit(item)">
                  تحرير
                </button>
                <ng-container *ngIf="isEditing(getId(item))">
                  <button class="btn" (click)="saveEdit(item)" [disabled]="isSaving(getId(item))">
                    حفظ
                  </button>
                  <button class="btn danger" (click)="cancelEdit(item)" [disabled]="isSaving(getId(item))">
                    إلغاء
                  </button>
                  <span class="mini-spinner" *ngIf="isSaving(getId(item))" aria-hidden="true"></span>
                  <span class="saving-label" *ngIf="isSaving(getId(item))">جاري الحفظ...</span>
                </ng-container>
              </div>
              <div class="matn" *ngIf="!isEditing(getId(item))" [innerHTML]="item._hadithNewOrg?.matn || item.matn"></div>
              <div class="editor" *ngIf="isEditing(getId(item))">
                <textarea [(ngModel)]="drafts[getId(item)]" rows="10" [disabled]="isSaving(getId(item))"></textarea>
              </div>
            </article>
          </div>
        </section>
      </ng-container>

      <ng-template #loadingTpl>
        <div class="state loading">
          <span class="spinner" aria-hidden="true"></span>
          <span>جاري التحميل...</span>
        </div>
      </ng-template>

      <ng-template #emptyTpl>
        <div class="state empty">لا توجد أحاديث لعرضها.</div>
      </ng-template>

      <ng-template #errorTpl>
        <div class="state error">حدث خطأ أثناء جلب البيانات. حاول مجدداً.</div>
      </ng-template>
    </div>
  `,
  styles: [`
    .container { padding: 24px; max-width: 1200px; margin: 0 auto; }
    
    .header { 
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 16px; 
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .back { 
      color: #1e40af; 
      text-decoration: none;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .back:hover { text-decoration: underline; }
    
    h1 { 
      margin: 0; 
      font-size: 24px; 
      color: #1e293b;
      font-weight: 600;
    }
    
    .meta { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      color: #475569;
      font-size: 14px;
    }
    
    .toast { 
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 12px 20px;
      border-radius: 8px;
      color: white;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      animation: slideIn 0.3s ease-out;
      max-width: 400px;
    }
    
    .toast.success { background-color: #10b981; }
    .toast.error { background-color: #ef4444; }
    
    @keyframes slideIn {
      from { transform: translateY(-100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    .list { display: flex; flex-direction: column; gap: 24px; }
    
    .hadith { 
      background: white; 
      border-radius: 12px; 
      padding: 20px; 
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      border: 1px solid #e2e8f0;
    }
    
    .actions { 
      display: flex; 
      gap: 8px; 
      justify-content: flex-end; 
      margin-bottom: 16px;
    }
    
    .btn { 
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .btn:not(:disabled):hover {
      transform: translateY(-1px);
    }
    
    .btn {
      background: #3b82f6;
      color: white;
    }
    
    .btn:hover:not(:disabled) {
      background: #2563eb;
    }
    
    .btn.secondary {
      background: #64748b;
      color: white;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: #475569;
    }
    
    .btn.danger {
      background: #ef4444;
      color: white;
    }
    
    .btn.danger:hover:not(:disabled) {
      background: #dc2626;
    }
    
    .matn { 
      font-size: 18px; 
      line-height: 1.8; 
      color: #1e293b;
      text-align: right;
    }
    
    .editor textarea { 
      width: 100%; 
      padding: 12px; 
      font-size: 16px; 
      line-height: 1.6; 
      font-family: inherit;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      min-height: 200px;
      resize: vertical;
    }
    
    .editor textarea:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }
    
    .mini-spinner { 
      width: 16px; 
      height: 16px; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%; 
      display: inline-block; 
      animation: spin 1s linear infinite;
      vertical-align: middle;
      margin-right: 8px;
    }
    
    .saving-label {
      display: inline-flex;
      align-items: center;
      color: #64748b;
      font-size: 14px;
    }
    
    .state { 
      display: flex; 
      align-items: center; 
      justify-content: center;
      gap: 12px; 
      padding: 24px;
      border-radius: 8px;
      margin: 20px 0;
      background: #f8fafc;
    }
    
    .state.loading { color: #3b82f6; }
    .state.error { color: #ef4444; background: #fef2f2; }
    .state.empty { color: #64748b; }
    
    .spinner { 
      width: 20px; 
      height: 20px; 
      border: 3px solid rgba(59, 130, 246, 0.2);
      border-top-color: #3b82f6;
      border-radius: 50%; 
      display: inline-block; 
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }
  `]
})
export class HadithPage {
  // Dependencies
  private readonly route = inject(ActivatedRoute);
  private readonly api = inject(HadithService);
  
  // State
  readonly items = signal<any[]>([]);
  readonly loaded = signal<boolean>(false);
  readonly error = signal<boolean>(false);
  readonly toastMessage = signal<string>('');
  readonly toastType = signal<'success' | 'error' | ''>('');
  
  // Form state
  private drafts: { [key: number]: string } = {};
  private editing: { [key: number]: boolean } = {};
  private saving: { [key: number]: boolean } = {};
  private toastTimeout: any = null;
  
  // Route parameters
  readonly catId = signal<number>(0);
  readonly chapterId = signal<number>(0);
  readonly babId = signal<number>(0);
  
  // Display data
  readonly writerName = signal<string>('');
  readonly chapterName = signal<string>('');
  readonly babName = signal<string>('');
  readonly bookName = signal<string>('');

  constructor() {
    // Initialize from route params
    const params = this.route.snapshot.paramMap;
    const queryParams = this.route.snapshot.queryParamMap;
    
    this.catId.set(Number(params.get('catId')) || 0);
    this.chapterId.set(Number(params.get('chapterId')) || 0);
    this.babId.set(Number(params.get('babId')) || 0);
    this.bookName.set(queryParams.get('book') || '');

    // Load initial data
    this.loadData();
  }
  
  // Public methods used in template
  getId = getHadithId;
  
  isEditing(id: number): boolean {
    return !!this.editing[id];
  }
  
  isSaving(id: number): boolean {
    return !!this.saving[id];
  }
  
  trackById(index: number, item: any): number {
    return this.getId(item);
  }
  
  // Toast helper
  private showToast(message: string, type: 'success' | 'error'): void {
    // Clear any existing timeout
    if (this.toastTimeout) {
      clearTimeout(this.toastTimeout);
    }
    
    // Set the message and type
    this.toastMessage.set(message);
    this.toastType.set(type);
    
    // Auto-hide after 3 seconds
    this.toastTimeout = setTimeout(() => {
      this.toastMessage.set('');
      this.toastType.set('');
    }, 3000);
  }
  
  // Data loading
  private loadData(): void {
    this.loaded.set(false);
    this.error.set(false);
    
    this.api.search(this.catId(), this.chapterId(), this.babId()).subscribe({
      next: (res: any) => {
        const grid = res?.gridData ?? [];
        const sorted = [...grid].sort((a, b) => {
          const aId = this.getId(a);
          const bId = this.getId(b);
          return aId - bId;
        });
        
        this.items.set(sorted);
        
        // Update header info from first item if available
        if (sorted.length > 0) {
          const first = sorted[0];
          this.writerName.set(first?._cat?.name || this.writerName());
          this.chapterName.set(first?._chapter?.name || '');
          this.babName.set(first?._bab?.name || '');
        }
        
        this.loaded.set(true);
      },
      error: (error) => {
        console.error('Error loading hadith data:', error);
        this.error.set(true);
        this.loaded.set(true);
        this.showToast('حدث خطأ أثناء تحميل البيانات', 'error');
      }
    });
  }
  
  // Form actions
  startEdit(item: any): void {
    const id = this.getId(item);
    this.drafts[id] = item?._hadithNewOrg?.matn || item?.matn || '';
    this.editing[id] = true;
  }
  
  cancelEdit(item: any): void {
    const id = this.getId(item);
    delete this.drafts[id];
    delete this.editing[id];
  }
  
  saveEdit(item: any): void {
    const id = this.getId(item);
    const raw = (this.drafts[id] ?? '').trim();
    const original = (item?._hadithNewOrg?.matn ?? item?.matn ?? '').trim();
    
    if (!raw) {
      this.showToast('النص لا يمكن أن يكون فارغاً', 'error');
      return;
    }
    
    if (raw === original) {
      this.showToast('لم يتم إجراء أي تغييرات', 'error');
      return;
    }
    
    this.saving[id] = true;
    
    // Optimistic update
    const updatedItem = { ...item };
    if (updatedItem._hadithNewOrg) {
      updatedItem._hadithNewOrg = { ...updatedItem._hadithNewOrg, matn: raw };
    } else {
      updatedItem.matn = raw;
    }
    
    this.items.update(items => 
      items.map(i => this.getId(i) === id ? updatedItem : i)
    );
    
    // Save to server
    this.api.editMatn(
      this.catId(),
      this.chapterId(),
      this.babId(),
      id,
      btoa(unescape(encodeURIComponent(raw))) // Simple base64 encode
    ).subscribe({
      next: (res: any) => {
        // Update with server response
        const updated = res?.gridData?.[0] || res;
        if (updated) {
          this.items.update(items => 
            items.map(i => this.getId(i) === id ? updated : i)
          );
        }
        
        // Clean up
        delete this.drafts[id];
        delete this.editing[id];
        delete this.saving[id];
        
        this.showToast('تم حفظ التعديل بنجاح', 'success');
      },
      error: (error) => {
        console.error('Error saving hadith:', error);
        
        // Revert optimistic update
        this.items.update(items => 
          items.map(i => this.getId(i) === id ? item : i)
        );
        
        delete this.saving[id];
        this.showToast('حدث خطأ أثناء حفظ التعديل', 'error');
      }
    });
  }
  
  // Clean up timeouts when component is destroyed
  ngOnDestroy(): void {
    if (this.toastTimeout) {
      clearTimeout(this.toastTimeout);
    }
  }
}
